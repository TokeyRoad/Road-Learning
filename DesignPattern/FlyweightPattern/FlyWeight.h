#pragma once
#include "../Common/head.h"


/*
FlyWeight(抽象享元类)：通常是一个抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），通常也可以通过这些方法来设置外部数据（外部状态）
ConcreteFlyWeight（具体享元类）：实现了抽象享元类，其实例称为享元对象，在具体享元类中为内部状态提供了存储空间，通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象
FlyweightFactory（享元工厂）：用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中

优点：
	可以极大的减少内存中对象的数量，使得相同或者相似对象在内存中只保留一份，从而可以节约系统资源，提高系统性能。
	享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象在不同的环境下可以共用
缺点：
	使系统复杂化，需要分离出内部状态和外部状态，这使得系统变得复杂化了
	为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态会使运行时间变长

适用：
	一个系统有大量相同或相似的对象，造成内存大量浪费
	对象的大部分状态可以外部化，可以将这些外部状态传入对象中
	在使用享元模式时，需要维护一个存储享元对象的享元池，这需要一定的系统资源，因此，只有在需要多次重复使用享元对象时才值得使用享元模式

案例：
	CS 将玩家分为“恐怖份子”（Terrorists）与“反恐精英”（Counter Terrorists）两个阵营，每个队伍必须在地图上进行多回合的战斗。在“爆破模式”中，T 阵营的任务是在指定时间内装置 C4 并引爆，而 CT 阵营的任务是拆除被装置的 C4。当玩家请求武器时，系统会为其分配所需的武器。

	现在，有 n 个玩 CS 的玩家，如果创建 n 个对象（每个玩家一个），这势必会占用大量内存。为了解决这个问题，可以使用享元模式（减少玩家数量），只需要为恐怖分子和反恐精英创建两个对象，在需要时反复使用即可。

*/

class IPlayer {
public:
	virtual ~IPlayer() {}

	virtual void assignWeapon(string weapon) = 0;
	virtual void misson() = 0;
protected:
	string m_task;
	string m_weapon;
};